package controllers

import ch.qos.logback.core.db.dialect.SQLDialect
import play.api.cache
import play.api.cache.Cache
import play.api.data.Form
import play.api.db.{DB, Database}
import play.api.i18n.MessagesApi
import play.api.mvc._

import scala.concurrent.Future

class Application(val db: Database, val messagesApi: MessagesApi) extends Controller with LegacyI18nSupport {

  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }

  def login = Action { implicit request =>
    // Initializes a database connection using Play's built-in Database API
    db.withConnection { connection =>
      val sql: DSLContext =
        // Creates a jOOQ DSLContext using the transaction
        DSL.using(connection, SQLDialect.POSTGRES_9_4)
      // Fetches all users into classes of the type UserRecord, generated by jOOQ
      val users = context.selectFrom[UserRecord](USER).fetch()
      // Displays the result as a response
      Ok(views.html.login(loginForm))
    }
  }

  // Defines the login form with email and password fields
  val loginForm = Form(
    tuple(
      "email"     -> email,
      "password"  -> text
    )
  )

  def authenticate = Action { implicit request =>
    // Binds the submitted form based on the request's body
    loginForm.bindFromRequest.fold(
      formWithErrors =>
        // Displays the login form again with validation errors
        BadRequest(views.html.login(formWithErrors)),
      login =>
        db.withConnection { connection =>
        val sql = DSL.using(connection, SQLDialect.POSTGRES_9_4)
        val user = Option( sql
            .selectFrom[UserRecord](USER)
            .where(USER.EMAIL.equal(login._1))
            .and(USER.PASSWORD.equal(crypto.sign(login._2)))
            // Executes the query that looks for the first user with the provided credentials
            .fetchOne())

        user.map { u =>
          Ok(s"Hello ${u.getFirstname}")
        } getOrElse {
          BadRequest(
            views.html.login(
              // Sets a global error if there are no users with the provided credentials
              loginForm.withGlobalError("Wrong username or password")
            )
          )
        }
        }
    )
  }

}



case class AuthenticatedRequest[A](userId: Long, firstName: String, lastName: String)


/**
  * Defines a new action using the ActionBuilder defined by Play
  *
  * Mixes in the Results trait in order to use the Redirect result later on
  */
object Authenticated extends ActionBuilder[AuthenticatedRequest] with Results {

  override def invokeBlock[A](request: Request[A],
                              block: (AuthenticatedRequest[A]) => Future[Result]): Future[Result] = {
    val authenticated = for {
      // Uses the code generated by jOOQ to fetch field names
      id        <- request.session.get(USER.ID.getName)
      firstName <- request.session.get(USER.FIRSTNAME.getName)
      lastName  <- request.session.get(USER.LASTNAME.getName)
      // Builds an AuthenticatedRequest based on the contents found in the session
    } yield AuthenticatedRequest[A](id.toLong, firstName, lastName)

    authenticated.map { authenticatedRequest =>
      block(authenticatedRequest)
    } getOrElse {
      Future.successful {
        // Redirects to the login page if the session doesn't contain the required parameters,
        // with an entirely new session, invalidating any erroneous session that may have existed.
        Redirect(routes.Application.login()).withNewSession
      }
    }

  }


  /**
    * First, try to fetch the user record from the cache, and in the case of a cache miss,
    * you query it in the DB and set its value in the cache.
    *
    * @param id
    * @return
    */
  def fetchUser(id: Long) =
    // Retrieves the user from the cache using the identifier as a key
    Cache.getAs[UserRecord](id.toString).map { user =>
      Some(user)
    } getOrElse {
      DB.withConnection { connection =>
        val sql = DSL.using(connection, SQLDialect.POSTGRES_9_4)
        val user = Option(
          sql
            .selectFrom[UserRecord](USER)
            .where(USER.ID.equal(id))
            // Queries for a user in the database in the case of a cache miss
            .fetchOne()
        )
        user.foreach { u =>
          // Sets the retrieved user in the cache
          Cache.set(u.getId.toString, u)
        }
        user
      }
    }

}